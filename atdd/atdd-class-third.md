# 행위 검증

- `verify()` 를 이용해서 어떤 함수가 호출되었는지 확인할 수 있다.

  - verify(line).getLine()

## 인수테스트 -> 컨트롤러 테스트 -> 서비스 테스트

- 인수테스트 통과를 위해서 컨트롤러 테스트를 수행할 때, 컨트롤러 내부에 있는 하위 메소드는 mocking 한다.
- 즉, 컨트롤러 테스트에서 `service` 가 mock의 대상이 되는 것이다.

# 도메인 모델 대신 DTO를 사용하는 이유

- 도메인 모델이 API 와 결합도가 높아지면서 `jsonIgnore` 같은 것에도 종속이 되고 그러기 때문.

# Interceptor 단위 테스트

- `HttpServletRequest` 와 같은 객체들은 초기 설정을 해줄 것이 너무 많기 때문에 `mock`(`fake`) 객체를 사용하는 것이 좋음

- 이렇게 `mock` 객체(`fake`)를 이용하는 것은 비즈니스 모델에서 필요는 없지만 테스트는 통과해야 할 때 사용할 수 있다.

# Mock으로 테스트를 통과 시킨 후에 실제 구현체를 만든다고 해서 그 mock을 걷어낼 필요는 없음

- 그럼 자신이 구현한 코드의 검증은 무슨 테스트로? -> 그 상위의 통합테스트나 인수테스트에서 검증이 될 것이다.

# 테스트 코드에서 중요한 점

- 가독성

# 인수 테스트로 모든 것을 검증하지 말자

- 가령 회원 정보를 조회할 때 잘못된 회원 정보를 보낸 경우 exception 이 발생한다면 이것을 인수테스트에서 검증하지 말고 인수테스트 하위의 단위 테스트에서 exception의 status code 값을 검증하는 단위테스트를 작성할 것

# 테스트에서 조건문을 사용하지 않는다

- fake 객체를 만들어서 사용하는데 fake 객체의 내용을 시나리오에 따라 다르게 한다고 하면, if 문을 사용하지 않고 테스트를 분리해주는 것이 가장 좋다.

# 실무에서 인수 테스트 상황이 되었을 때

- 비슷한 fixture 끼리 묶어서 테스트를 진행한다.

- i.e. dbUnit 을 사용해서 테스트를 수행하기 전과 후의 쿼리를 쓸 수 있다.

- 실무에서는 dirtyContext 를 사용하는 것이 매우 드물다

- JUnit5 의 @nested 어노테이션을 사용해도 된다. -> 하지만 별도의 테스트로 분리하는 것이 더 좋다.

# mock 과 fake

- 테스트 대상이 되는 객체가 다른 객체들과 너무 많은 연결이 이루어지고 있다 -> 이 경우 `fake`를 사용하면 이 객체가 가지고 있는 의존관계가 정말 필요한 것인지 확인이 가능하다. 왜냐하면 `mock` 대신 `fake` 를 사용하는 게 불편하기 때문이다.

---

# REST API 제약 조건

- stateless 제약 조건: 클라이언트가 모든 정보를 가지고 있고, 서버는 클라이언트 맥락에 대한 정보가 필요가 없다
- REST API 를 통해서 `/stations/1` 이라는 URI 로 접근을 하면 응답을 받을 때 json 형식으로도 받을 수 있고 page 형식으로도 받을 수 있다.

  - 이 형태는 `content-type` 라는 타입을 통해서 다르게 응답을 받을 수 있다.
  - REST API 를 통해서 받을 수 있는 _리소스_ 는 `station` 이라는 추상적 개념 조건이지 page 타입이냐 json 타입이냐 등의 우리가 받는 실물 응답이 아니다.
  - JSON 응답 값은 자기 서술적이지 못함. -> 그래서 링크와 프로파일 값을 같이 넣어주어야 함

- REST API 는 아키텍쳐의 개념으로 봐야지 통신규약의 의미로 받아들이지 말자

---

# TDD - inner peace

- 테스트를 통과해서 green 상태일 때 반드시 커밋을 하자! -> 일종의 세이브 포인트 개념

# ATDD 테스트

- presentation layer

  - service 같은 것들은 presentation layer 가 아님.
  - 인터셉터 / 핸들러 아큐먼트 리졸버 등

- business layer

  - 트랜젝션 확인을 위한 통합 테스트

- persistance layer

  - crudrepository 가 제공하는 기본 메소드는 테스트 하지 않음
  - `findByEmail` 등과 같이 기본 메소드가 아닌 개발자가 직접 선언해준 명세 등을 테스트
  - entity 설계 중 cascade 설정시 전파 정도를 확인해야 하는 경우를 테스트
    - cascade 를 설정했다면 `line` 을 지웠는데 `edge` 도 같이 지워지는지 등을 이야기한다.

# 문서화

- spring rest docs: 프로덕션 코드가 아니라 테스트 코드에 설정한다.

# 3주차 미션

- 문서 html 파일을 리소스 디렉토리에 옮긴다
